<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Minesweeper</title>
	<style type="text/css">
		html,
		body {
			margin: 0;
			font-size: 0;
		}
		canvas {
			width: 100vw;
			max-width: 100vh;
			height: 100vh;
			max-height: 100vw;
			background-color: #ccc;
			cursor: pointer;
		}
		span {
			color: black;
			font-size: 5vh;
			font-family: helvetica;
			vertical-align: bottom;
			text-wrap: nowrap;
		}
		span button {
			font-size: 5vh;
		}
	</style>
</head>
<body>
	<canvas></canvas>
	<span></span>

	<script type="text/javascript">
		var FIELD_LENGTH = 16
		var MINES = 40

		function generateField() {
			function arr(length, fn) {
				return Array.from({ length }, fn)
			}

			function hasMine(fieldX, fieldY) {
				if (!(fieldX >= 0 && fieldY >= 0 && fieldX < FIELD_LENGTH && fieldY < FIELD_LENGTH)) {
					return false
				}
				return field[fieldX][fieldY].mine
			}

			function touching(fieldX, fieldY) {
				return 0
					+ hasMine(fieldX - 1, fieldY)
					+ hasMine(fieldX, fieldY - 1)
					+ hasMine(fieldX + 1, fieldY)
					+ hasMine(fieldX, fieldY + 1)
					+ hasMine(fieldX - 1, fieldY - 1)
					+ hasMine(fieldX - 1, fieldY + 1)
					+ hasMine(fieldX + 1, fieldY - 1)
					+ hasMine(fieldX + 1, fieldY + 1)
			}

			var field = arr(FIELD_LENGTH, () =>
				arr(FIELD_LENGTH, () => ({
					mine: false,
					covered: true,
					mark: 'none', // Marks: 'none', 'flagged', 'question'
					touching: 0,
				}))
			)
			for (var minesLaid = 0; minesLaid < MINES;) {
				var x = Math.floor(Math.random() * FIELD_LENGTH)
				var y = Math.floor(Math.random() * FIELD_LENGTH)
				if (!field[x][y].mine) {
					field[x][y].mine = true
					minesLaid++
				}
			}

			for (var i = 0; i < FIELD_LENGTH; i++) {
				for (var j = 0; j < FIELD_LENGTH; j++) {
					field[i][j].touching = touching(i, j)
				}
			}

			return field
		}

		function drawField(field, canvas, context) {
			function drawLine(x1, y1, x2, y2) {
				context.beginPath()
				context.moveTo(x1, y1)
				context.lineTo(x2, y2)
				context.stroke()
			}

			function drawHorizontalLine(y) {
				drawLine(0, y, canvas.width, y)
			}

			function drawVerticalLine(x) {
				drawLine(x, 0, x, canvas.height)
			}

			function drawMine(fieldX, fieldY) {
				var width = canvas.width / FIELD_LENGTH
				var height = canvas.height / FIELD_LENGTH
				var x = width * (fieldX + 0.5)
				var y = height * (fieldY + 0.5)
				context.beginPath()
				context.fillStyle = 'red'
				context.arc(x, y, height * 0.4, 0, 2 * Math.PI)
				context.fill()
				context.stroke()
			}

			function drawTouching(fieldX, fieldY, touching) {
				var color = [ null, 'blue', 'green', 'red', 'darkblue', 'darkred', 'darkred', 'darkred', 'darkred' ][touching]
				var text = touching.toString()
				drawText(fieldX, fieldY, text, color)
			}

			function drawText(fieldX, fieldY, text, color) {
				var x = canvas.width / FIELD_LENGTH * (fieldX + 0.2)
				var y = canvas.height / FIELD_LENGTH * (fieldY + 0.85)
				context.font = (canvas.width / FIELD_LENGTH) + 'px helvetica'
				context.fillStyle = color
				context.fillText(text, x, y)
			}

			function drawDarkBox(fieldX, fieldY) {
				var width = canvas.width / FIELD_LENGTH
				var height = canvas.height / FIELD_LENGTH
				var x1 = width * fieldX
				var y1 = height * fieldY
				context.fillStyle = 'darkgray'
				context.fillRect(x1 + 1, y1 + 1, width - 2, height - 2)
				context.fillStyle = 'black'
			}

			context.clearRect(0, 0, canvas.width, canvas.height)
			for (var i = 1; i < FIELD_LENGTH; i++) {
				drawHorizontalLine(canvas.height / FIELD_LENGTH * i)
				drawVerticalLine(canvas.width / FIELD_LENGTH * i)
			}

			var win = true
			var lose = false
			for (var i = 0; i < FIELD_LENGTH; i++) {
				for (var j = 0; j < FIELD_LENGTH; j++) {
					var cell = field[i][j]

					if (!cell.mine && cell.covered) {
						win = false
					}
					if (!cell.covered) {
						drawDarkBox(i, j)
						if (cell.mine) {
							drawMine(i, j)
							lose = true
						} else if (cell.touching) {
							drawTouching(i, j, cell.touching)
						}
					} else if (cell.mark === 'flagged') {
						drawText(i, j, '!!', 'red')
					} else if (cell.mark === 'question') {
						drawText(i, j, '?', 'darkgray')
					}
				}
			}

			return win ? 'win' : (lose ? 'lose' : '')
		}

		function uncover(field, fieldX, fieldY) {
			if (fieldX >= 0 && fieldY >= 0 && fieldX < FIELD_LENGTH && fieldY < FIELD_LENGTH) {
				var cell = field[fieldX][fieldY]
				var prevCovered = cell.covered
				cell.covered = false
				if (!cell.mine && !cell.touching && prevCovered) {
					uncover(field, fieldX - 1, fieldY)
					uncover(field, fieldX, fieldY - 1)
					uncover(field, fieldX + 1, fieldY)
					uncover(field, fieldX, fieldY + 1)
					uncover(field, fieldX - 1, fieldY - 1)
					uncover(field, fieldX - 1, fieldY + 1)
					uncover(field, fieldX + 1, fieldY - 1)
					uncover(field, fieldX + 1, fieldY + 1)
				}
			}
		}

		var canvas = document.querySelector('canvas')
		canvas.width = canvas.clientWidth
		canvas.height = canvas.clientHeight
		var context = canvas.getContext('2d')

		var span = document.querySelector('span')

		var firstUncover = true
		var winOrLose = false

		canvas.onclick = function (e) {
			if (winOrLose) {
				return
			}
			var x = Math.floor(e.clientX / canvas.width * FIELD_LENGTH)
			var y = Math.floor(e.clientY / canvas.height * FIELD_LENGTH)

			var cell = field[x][y]

			// Make it so your first click can't be on a mine
			// It might be cleaner to generate the mines after the first click
			while (firstUncover && cell.mine) {
				field = generateField()
				cell = field[x][y]
			}
			firstUncover = false

			uncover(field, x, y)
			winOrLose = drawField(field, canvas, context)
			if (winOrLose) {
				span.innerHTML = 'You ' + winOrLose + '!  <button onclick="window.location.reload()">Play Again</button>'
			}
		}

		canvas.oncontextmenu = function (e) {
			var x = Math.floor(e.clientX / canvas.width * FIELD_LENGTH)
			var y = Math.floor(e.clientY / canvas.height * FIELD_LENGTH)
			var cell = field[x][y]
			if (cell.covered) {
				cell.mark = {
					none: 'flagged',
					flagged: 'question',
					question: 'none'
				}[cell.mark]
				drawField(field, canvas, context)
			}
			return false
		}

		var field = generateField()
		drawField(field, canvas, context)
	</script>
</body>
</html>
